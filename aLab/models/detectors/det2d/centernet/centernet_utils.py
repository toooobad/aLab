# -*- coding: utf-8 -*-
# @Author  : ace
# Copyright by Ace, All Rights Reserved.

import torch
import numpy as np

from math import sqrt
from torch import Tensor
from typing import (Union, List, Tuple)


__all__ = ['gaussian_radius', 'draw_umich_gaussian', 'gaussian2d']


def gaussian2d(diameters: Union[List[int], Tuple[int]], sigma_x: float = 1, sigma_y: float = 1) -> np.ndarray:
    diameter_y, diameter_x = [(d - 1.) / 2. for d in diameters]
    y, x = np.ogrid[-diameter_y: diameter_y + 1, 
                    -diameter_x: diameter_x + 1]

    gaussian = np.exp(-(x * x / (2 * sigma_x * sigma_x) + y * y / (2 * sigma_y * sigma_y)))
    gaussian[gaussian < np.finfo(gaussian.dtype).eps * gaussian.max()] = 0

    return gaussian


def gaussian_radius(obj_shape: Union[List[int], Tuple[int]], min_overlap: float) -> float:
    r"""Generate 2D gaussian radius.

    This function is modified from the `official github repo
    <https://github.com/princeton-vl/CornerNet-Lite/blob/master/core/sample/
    utils.py#L65>`_.

    Given ``min_overlap``, radius could computed by a quadratic equation
    according to Vieta's formulas.

    There are 3 cases for computing gaussian radius, details are following:

    - Explanation of figure: ``lt`` and ``br`` indicates the left-top and
      bottom-right corner of ground truth box. ``obj_x`` indicates the
      generated corner at the limited position when ``radius=r``.

    - Case1: one corner is inside the gt box and the other is outside.

    .. code:: text

        |<   obj_width   >|

        lt-+----------+         -
        |  |          |         ^
        +--obj_x----------+--+
        |  |          |  |
        |  |          |  |    obj_height
        |  | overlap  |  |
        |  |          |  |
        |  |          |  |      v
        +--+---------br--+      -
           |          |  |
           +----------+--obj_x

    To ensure IoU of generated box and gt box is larger than ``min_overlap``:

    .. math::
        \cfrac{(w-r)*(h-r)}{w*h+(w+h)r-r^2} \ge {iou} \quad\Rightarrow\quad
        {r^2-(w+h)r+\cfrac{1-iou}{1+iou}*w*h} \ge 0 \\
        {a} = 1,\quad{b} = {-(w+h)},\quad{c} = {\cfrac{1-iou}{1+iou}*w*h}
        {r} \le \cfrac{-b-\sqrt{b^2-4*a*c}}{2*a}

    - Case2: both two corners are inside the gt box.

    .. code:: text

        |<   obj_width   >|

        lt-+----------+         -
        |  |          |         ^
        +--obj_x-------+  |
        |  |       |  |
        |  |overlap|  |       obj_height
        |  |       |  |
        |  +-------obj_x--+
        |          |  |         v
        +----------+-br         -

    To ensure IoU of generated box and gt box is larger than ``min_overlap``:

    .. math::
        \cfrac{(w-2*r)*(h-2*r)}{w*h} \ge {iou} \quad\Rightarrow\quad
        {4r^2-2(w+h)r+(1-iou)*w*h} \ge 0 \\
        {a} = 4,\quad {b} = {-2(w+h)},\quad {c} = {(1-iou)*w*h}
        {r} \le \cfrac{-b-\sqrt{b^2-4*a*c}}{2*a}

    - Case3: both two corners are outside the gt box.

    .. code:: text

           |<   obj_width   >|

        obj_x--+----------------+
        |  |                |
        +-lt-------------+  |   -
        |  |             |  |   ^
        |  |             |  |
        |  |   overlap   |  | obj_height
        |  |             |  |
        |  |             |  |   v
        |  +------------br--+   -
        |                |  |
        +----------------+--obj_x

    To ensure IoU of generated box and gt box is larger than ``min_overlap``:

    .. math::
        \cfrac{w*h}{(w+2*r)*(h+2*r)} \ge {iou} \quad\Rightarrow\quad
        {4*iou*r^2+2*iou*(w+h)r+(iou-1)*w*h} \le 0 \\
        {a} = {4*iou},\quad {b} = {2*iou*(w+h)},\quad {c} = {(iou-1)*w*h} \\
        {r} \le \cfrac{-b+\sqrt{b^2-4*a*c}}{2*a}

    Args:
        obj_shape (Uion[List[int], Tuple[int]]): Shape of object. (obj_height, obj_width)
        min_overlap (float): Min IoU with ground truth for boxes generated by
            keypoints inside the gaussian kernel.

    Returns:
        radius (int): Radius of gaussian kernel.
    """
    obj_height, obj_width = obj_shape

    a1 = 1
    b1 = (obj_height + obj_width)
    c1 = obj_width * obj_height * (1 - min_overlap) / (1 + min_overlap)
    sq1 = sqrt(b1 ** 2 - 4 * a1 * c1)
    r1 = (b1 - sq1) / (2 * a1)

    a2 = 4
    b2 = 2 * (obj_height + obj_width)
    c2 = (1 - min_overlap) * obj_width * obj_height
    sq2 = sqrt(b2 ** 2 - 4 * a2 * c2)
    r2 = (b2 - sq2) / (2 * a2)

    a3 = 4 * min_overlap
    b3 = -2 * min_overlap * (obj_height + obj_width)
    c3 = (min_overlap - 1) * obj_width * obj_height
    sq3 = sqrt(b3 ** 2 - 4 * a3 * c3)
    r3 = (b3 + sq3) / (2 * a3)

    return min(r1, r2, r3)


def draw_umich_gaussian(heatmap: Tensor, obj_center: Union[List[int], Tuple[int]], radius: int, k: int = 1) -> Tensor:
    """
    copy from centernet <https://github.com/xingyizhou/CenterNet/blob/master/src/lib/utils/image.py, line 126>
    """
    diameter = 2 * radius + 1
    sigma = diameter / 6

    gaussian = gaussian2d((diameter, diameter), sigma_x=sigma, sigma_y=sigma)
    gaussian = heatmap.new_tensor(gaussian)
    
    obj_x, obj_y = int(obj_center[0]), int(obj_center[1])

    heatmap_height, heatmap_width = heatmap.shape[0:2]
        
    left, right = min(obj_x, radius), min(heatmap_width - obj_x, radius + 1)
    top, bottom = min(obj_y, radius), min(heatmap_height - obj_y, radius + 1)

    masked_heatmap  = heatmap[obj_y - top:obj_y + bottom, obj_x - left:obj_x + right]
    masked_gaussian = gaussian[radius - top:radius + bottom, radius - left:radius + right]

    if min(masked_gaussian.shape) > 0 and min(masked_heatmap.shape) > 0:
        torch.max(masked_heatmap, masked_gaussian * k, out=masked_heatmap)

    return heatmap